How can developers and clients benefit from data being in a file format when there are so many other options out there? Why not just use a simple HTML page with AJAX requests and tables to display the data? In this blog post, let me show you why it may be a good idea to construct files using python to create and fill them with data. We will go over a few APIs to populate our files with data and how to use the Requests HTTP library to fetch data. In this post, we'll be using Python 3 and its toolkit.

Setting Objectives

Let's set objectives for our files! First, we want some inspiration. We will form a request to a famous quotes API using the Requests module in Python. Second, we want to make sure our investments in the stock market are looking solid. We'll use IEXFinance Python wrapper around the Investors Exchange Developer API. Third, we also want to make sure our cryptocurrencies are staying green as well. We'll fetch data with the Requests module from the Coinbase API to check on our digital assets. Lastly, we'll take all this fetched data and write to files that correspond to each time we run the script and have one accumulative file. All of our files will be in CSV format. I am assuming that we will utilize the functionality of spreadsheet software to graph this data we store in the files. Let's dive into how the Requests HTTP library works and get our quotes!

Using the Requests Module

The Requests HTTP Library is an elegant way to make HTTP requests without the need to do manual labor of forming the query-strings or to form-encode POST data. Our primary focus will be making a GET request to TheySaidSo or FavQs API to fetch our inspirational quote. First thing, we need to install the Requests library in our project's directory. In a Unix terminal, you can simply run 'pipenv install requests' if you have pipenv installed. If you don't have pipenv installed, use 'pip install pipenv' to install it!

Getting Inspiration by Fetching Quotes

Now that you have the Requests library available to use; let's form our first request. Since we will be tracking our favorite stocks and crypto coins, it may be a good idea to add hope to our file. We will form an API Get request to theysaidso.com's quotes API. The 'quote of the day' endpoint is straightforward to digest and will give us some inspiration when we need it most. Alternatively, you can also use the FavQs API. This quote API will allow for more requests if you plan to use the script more than 10 times per hour. Now it is time to form that request and format the response!

Above you'll see how we form the request and format the response. I provided an example for both APIs. I'll be referencing FavQs's API since I'm not paying for TheySaidSo's API. This way I can always have a quote each time I run the script since I won't hit their rate limit of 30 requests per 20 seconds. First, we make the request, and when it succeeds, we receive a response which needs JSON decoding. After decoding the response, we are able to simply combine the dictionary key/value pairs into a formatted string. This string will be ('quote' - 'author'). Not to forget, we may receive commas in the quote. We need to use the replace() function to replace all commas with HTML hex code value for commas or a value of your choosing that is still easily replaceable. Replacing it with the hex code value will enable future replacement to be just as easy. We can store this string as a constant to use later when we write it to our file. Next, let's fetch our favorite stocks prices.

Lassoing the Data-Driven Bull

There are a plethora of python modules to assist you in receiving stock information. I chose IEXFinance module which wraps around the Investors Exchange Developer API. You'll need to run 'pip install iexfinance' to have the module accessible in the script file. It provides a plethora of valuable features including real-time quotes, historical data, trading analyses, etc. We are only concerned with getting the stock price at the time we run the script. Analyzing the code above, we use the Stock() function to call a single ticker. We do this three times to keep the code simple, but you can use a list inside of Stock() to fetch various ticker information. Our top priority is to get the price of our favorite stocks: Tesla, Apple, and Google (Alphabet). Using the constants, we can call get_price() on them. The get_price() function returns a float which we need to convert into a string. I decided to use the str() function for conversion to maintain readability. Excellent, we have stock prices stored and a quote ready. It is time to get our crypto coin prices!

Catching Coins with Virtual Flips

Coinbase is one of the most famous exchanges operating today. Since Coinbase is very popular, they have graced their developer community with a superb API. They are also gracious to allow 10,000 API calls per hour! For this demonstration, I'll be checking the buy price of BTC, ETH, and LTC to USD. Looking at the provided example, we need to form three requests to the Coinbase API-- one for each currency. We get the response object on success, decode the JSON, then we set that amount to a constant per coin. Now that we have our quote, stock prices, and crypto prices there are only a few more steps we need to do to format the data correctly.

Now it is time to get our data formatted correctly for our files we will be creating and updating. First, we need to think about how we will be naming our generated files and the organization structure. In my example, I use an output directory with the main file named master.csv and sub-directory named 'individual.' Within the 'individual' directory, I place the file we generate each time we run the script. What should the name be? 

All in a Good Time

How about we use the DateTime module! I chose 'stock-crypto-check-YYYY-MM-DD-HH-MM' because we will generate a new file name each minute we run the script. I'm not concerned about running this down to seconds, so delimiting by minutes works for me. If you plan to run it once a day or once an hour, just change the formatting to remove the time format depending on your desired interval. In the example above, you'll see I created two other time formats as well. These two be in their corresponding files. I'm using the DateTime module by calling for today's date and time. I format the date constant by using the strftime() function which formats the date string using format codes. Let's revisit the data we received from our requests and module functions to get it ready for the files.

Formatted Strings Attached

Since we are writing and appending to CSV files, we need to start with a comma delimitated header line. I think going by ticker and price to start makes sense, but I also want to include our date and quote on the last line we write. Those fields will be the last two in the header and only filled on the last line of the output. When writing to a file, we need to be sure we create new lines. According to the python documentation, we can use '\n' on a Unix machine ('\r\n' for Windows). Our stock and crypto strings ought to follow how we set up our header. Since we have three stocks and coins; I'll have six tickers, prices, and new lines but I'll have twelve empty cells in total. Each stock and cryptocurrency group will need a newline to ensure we follow the format correctly. Now that we have our stock and cryptocurrency strings formatted, we can move onto the satisfying part. Let's write all of this data to our files!

Poetry in Motion

The most crucial part is ensuring we have our directories made for the master and individual files. Otherwise, we will get a 'FileNotFoundError' if the directory is not found.  First, let's create the master.csv file. The first argument is the name of the file and the second argument is the mode. Using the open function with 'a' as the mode signifies we will be appending to the file named. The appending mode will create the file if it does not exist, if it does, it will write after the last line. I only want to add the header once, so I opted to use the OS module to check the size of the file in bytes. If the file is brand new the size will be 0; thus we can add the header. Since this only happens once, you may opt to create the master.csv and add the header manually before running the script. Finally, the best part, we write our formatted data to the file. Since we are writing three lines (excluding the header), three write functions are needed. The last write function we will format our date and quote. To follow the header fields, we need two empty columns to start. Then we can concatenate master date and quote followed by a newline since we are appending to the master.csv file. We must close the file (using the close() function) once we are done to ensure we free up system resources used by the file.

For the individual files, we will follow the same pattern with a few minor changes. First, we will use the formatted file date within the name parameter of the open function and use the 'w' mode for writing. If you run the script within the same minute, then the previous file will be overwritten with the latest data received. You can prevent this from happening by adding seconds to the file name. Unlike the master file, want to add the header each time. We will run the write function four times in total for our individual files. The only other difference is not needing the newline after the date and quote data.

In Conclusion

Shazam! We now have a working script to generate output data to use for historical purposes with other projects. There is plenty of room to improve the code shown; using python 3.x convention, refactoring the Stock() function, use the context manager for opening files, etc. This tutorial gives you a starting point with a clear understanding of the capabilities to create a script to dynamically generate files and update existing ones. I hope you have gained insight about using data to write to files and generate dynamic files programmatically. Happy coding!

